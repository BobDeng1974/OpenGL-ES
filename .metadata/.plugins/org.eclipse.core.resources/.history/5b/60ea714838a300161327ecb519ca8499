package com.example.opengles_stenciltest;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;

import android.opengl.GLES20;

public class Shape {
	private FloatBuffer mRectangleBuffer;
	private int mProgram; 
	private int mPositionHandle;
	private int muMVPMatrixHandle;
	private FloatBuffer mLineBuffer;

	public Shape(float r) {
		initVetexData(r);
	}

	public void initVetexData(float i) {
		float rectangleVertices[] = new float[] {
				(float) -0.5, (float) -0.5,
				(float) 0.5, (float) -0.5,
				(float) -0.5, (float) 0.5,
				(float) 0.5, (float) 0.5
				};

		float lineVertices[] = new float[] {
				0, (float) -1,
				0, (float) 1,
				};
		
		ByteBuffer rvbb = ByteBuffer.allocateDirect(rectangleVertices.length * 4);
		rvbb.order(ByteOrder.nativeOrder());// 设置字节顺序
		mRectangleBuffer = rvbb.asFloatBuffer();// 转换为Float型缓冲
		mRectangleBuffer.put(rectangleVertices);// 向缓冲区中放入顶点坐标数据
		mRectangleBuffer.position(0);// 设置缓冲区起始位置

		
		ByteBuffer lvbb = ByteBuffer.allocateDirect(rectangleVertices.length * 4);
		lvbb.order(ByteOrder.nativeOrder());// 设置字节顺序
		mLineBuffer = lvbb.asFloatBuffer();// 转换为Float型缓冲
		mLineBuffer.put(lineVertices);// 向缓冲区中放入顶点坐标数据
		mLineBuffer.position(0);// 设置缓冲区起始位置
		
		int vertexShader = loaderShader(GLES20.GL_VERTEX_SHADER,
				vertexShaderCode);
		int fragmentShader = loaderShader(GLES20.GL_FRAGMENT_SHADER,
				fragmentShaderCode);

		mProgram = GLES20.glCreateProgram();
		GLES20.glAttachShader(mProgram, vertexShader);
		GLES20.glAttachShader(mProgram, fragmentShader);
		GLES20.glLinkProgram(mProgram);

		mPositionHandle = GLES20.glGetAttribLocation(mProgram, "aPosition");
		muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix");
	}

	public void draw(float[] mvpMatrix) {
		GLES20.glUseProgram(mProgram);
		// 将顶点数据传递到管线，顶点着色器
		GLES20.glVertexAttribPointer(mPositionHandle, 2, GLES20.GL_FLOAT,
				false, 2 * 4, mRectangleBuffer);
		GLES20.glEnableVertexAttribArray(mPositionHandle);
		GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mvpMatrix, 0);
		// 绘制图元
		GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
	}

	private int loaderShader(int type, String shaderCode) {
		int shader = GLES20.glCreateShader(type);
		GLES20.glShaderSource(shader, shaderCode);
		GLES20.glCompileShader(shader);
		return shader;
	}

	private String vertexShaderCode = "uniform mat4 uMVPMatrix;"
			+ "attribute vec2 aPosition;"
			+ "void main(){"
			+ "gl_Position = uMVPMatrix * vec4(aPosition, 0, 1);" 
			+ "}";

	private String fragmentShaderCode = "precision mediump float;"
			+ "void main(){"
			+ "gl_FragColor = vec4(1,0,0,0);"
			+ "}";

}
